# -*- coding: utf-8 -*-
"""ProjectHPCFinal_ThaySon.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u2ZqRxeBOaiwr44bWdVkzPKFj1xqluQ2
"""

from numba import cuda
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import time
import math

root = mpimg.imread('/content/drive/MyDrive/phongcanh.png')
imgplot = plt.imshow(root)
plt.show()

#Convert RGB to HSV -- GPU
@cuda.jit(device=True)
def rgb_to_hsv_gpu(src, dst):
    tidx = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x
    tidy = cuda.threadIdx.y + cuda.blockIdx.y * cuda.blockDim.y 
        
    r = src[tidx, tidy, 2]/255
    g = src[tidx, tidy, 1]/255
    b = src[tidx, tidy, 0]/255
    
    tidMax = max(r, g, b)
    tidMin = min(r, g, b)
    
    df = tidMax - tidMin
    
    if df == 0:
        dst[tidx, tidy, :] = 0
    elif r == tidMax:
        dst[tidx, tidy, 0] = ((((g - b) / df) % 6) * 60) % 360    
    elif g == tidMax:
        dst[tidx, tidy, 0] = ((((b - r) / df) + 2) * 60) % 360
    elif b == tidMax:
        dst[tidx, tidy, 0] = ((((r - g) / df) + 4) * 60) % 360
        
    if tidMax == 0:
        dst[tidx, tidy, 1] = 0
    else:
        dst[tidx, tidy, 1] = (df/tidMax) * 100
    
    dst[tidx, tidy, 2] = tidMax*100
    
    start_hsv = time.time()
    rgb_to_hsv_gpu[gridSize, blockSize](devInput1, devOutput1)
    hostOutput1 = devOutput1.copy_to_host()
    print("GPU hsv time :",abs(time.time()-start_hsv))
    plt.imsave("HSV_lab10.png",hostOutput1)
    devInput2 = cuda.to_device(hostOutput1)

#Convert RGB to HSV -- CPU
def rgb_to_hsv_cpu(src):
    height, width = src.shape[0], src.shape[1]
    dst_hsv = np.zeros((height, width, 3), dtype=np.uint8)
    for tidx in range(height):
        for tidy in range(width):
            r = src[tidx, tidy, 2]/255
            g = src[tidx, tidy, 1]/255
            b = src[tidx, tidy, 0]/255

            c_max = max(r, g, b)
            c_min = min(r, g, b)
            df = c_max - c_min
            if df == 0:
                h = 0
            elif c_max == r:
                h = ((((g - b) / df) % 6) * 60)  % 360
            elif c_max == g:
                h = ((((b - r) / df) + 2) * 60) % 360
            elif c_max == b:
                h = ((((r - g) / df) + 4) * 60) % 360
            if c_max == 0:
                s = 0
            else:
                s = df / c_max
            v = c_max

            dst_hsv[tidx, tidy, 0] = h % 360
            dst_hsv[tidx, tidy, 1] = s * 100
            dst_hsv[tidx, tidy, 2] = v * 100
    return dst_hsv

# display HSV image
hsv = rgb_to_hsv_cpu(root)
imgplot = plt.imshow(hsv)
plt.show()


height, width = root.shape[0], root.shape[1]
pixelCount = width * height
blockSize = (8,8)
gridSize = (math.ceil(height/blockSize[0]), math.ceil(width/blockSize[1]))
devOutput1 = cuda.device_array(np.shape(root),np.uint8)
devOutput2 = cuda.device_array(np.shape(root),np.uint8)
devInput1 = cuda.to_device(root)
image1 = np.zeros((height, width, 3),np.uint8)
image2 = np.zeros((height, width, 3),np.uint8)

def kuwahara_cpu(root,v,size): #WIP
    for i in range(height):
        for j in range(width):
            sizes = (((i-size,i),(j-size,j)),((i,i+size),(j-size,j)),((i-size,i),(j,j+size)),((i,i+size),(j,j+size)))  

            sum1 = 0
            totalsum = 0
            for i in range(sizes[0][0]):
                for j in range(sizes[0][1]):
                    sum1 = sum1 + (v[i,j])
                    totalsum = totalsum + (v[i,j] * v[i,j])
            resultdev1 = math.sqrt(abs(totalsum / (size *2) - (sum1 / (size *2)) *2)) 

            sum2 = 0
            for i in range(sizes[1][0]):
                for j in range(sizes[1][1]):
                    sum2 = sum2 + v[i,j]
                    totalsum = totalsum + v[i,j] * v[i,j]
            resultdev2 = math.sqrt(abs(totalsum / (size **2) - (sum1 / (size *2)) *2)) 

            sum3 = 0      
            for i in range(sizes[2][0]):
                for j in range(sizes[2][1]):
                    sum3 = sum3 + v[i,j]
                    totalsum = totalsum + v[i,j] * v[i,j]
            resultdev3 = math.sqrt(abs(totalsum / (size *2) - (sum3 / (size *2)) *2)) 
            
            sum4 = 0
            for i in range(sizes[3][0]):
                for j in range(sizes[3][1]):
                    sum4 = sum4 + v[i,j]
                    totalsum = totalsum + v[i,j] * v[i,j]
            resultdev4 = math.sqrt(abs(totalsum / (size *2) - (sum4 / (size *2)) *2)) 
            Min = min(resultdev1,resultdev2,resultdev3,resultdev4)
            result_dev = (resultdev1,resultdev2,resultdev3,resultdev4)
            r = 0
            g = 0
            b = 0

            for si in (range(4)):
                for sj in range(4):
                    if Min == result_dev[si]:
                        for i in (sizes[sj][0]):
                            for j in (sizes[sj][1]):
                                r = r + root[i,j,2]
                                g = g + root[i,j,1]
                                b = b + root[i,j,0]
    root[i,j,2] = r / size*2
    root[i,j,1] = g / size*2
    root[i,j,0] = b / size*2 


@cuda.jit(device=True)
def kuwahara_gpu(src, v, dst, size):
    tidx = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x
    tidy = cuda.threadIdx.y + cuda.blockIdx.y * cuda.blockDim.y

    sizes = (((tidx-size,tidx),(tidy-size,tidy)),((tidx,tidx+size),(tidy-size,tidy)),((tidx-size,tidx),(tidy,tidy+size)),((tidx,tidx+size),(tidy,tidy+size)))
    
    sum1 = 0
    totalsum = 0
    for i in range(sizes[0][0]):
        for j in range(sizes[0][1]):
            sum1 = sum1 + (v[i,j])
            totalsum = totalsum + (v[i,j] * v[i,j])
            resultdev1 = math.sqrt(abs(totalsum / (size *2) - (sum1 / (size *2)) *2)) 

            sum2 = 0
            for i in range(sizes[1][0]):
                for j in range(sizes[1][1]):
                    sum2 = sum2 + v[i,j]
                    totalsum = totalsum + v[i,j] * v[i,j]
            resultdev2 = math.sqrt(abs(totalsum / (size **2) - (sum1 / (size *2)) *2)) 

            sum3 = 0      
            for i in range(sizes[2][0]):
                for j in range(sizes[2][1]):
                    sum3 = sum3 + v[i,j]
                    totalsum = totalsum + v[i,j] * v[i,j]
            resultdev3 = math.sqrt(abs(totalsum / (size *2) - (sum3 / (size *2)) *2)) 
            
            sum4 = 0
            for i in range(sizes[3][0]):
                for j in range(sizes[3][1]):
                    sum4 = sum4 + v[i,j]
                    totalsum = totalsum + v[i,j] * v[i,j]
            resultdev4 = math.sqrt(abs(totalsum / (size *2) - (sum4 / (size *2)) *2)) 
            Min = min(resultdev1,resultdev2,resultdev3,resultdev4)
            result_dev = (resultdev1,resultdev2,resultdev3,resultdev4)
            r = 0
            g = 0
            b = 0
            
            for j in range(4):
                if Min == result_dev[j]:
                    temp = j
                for i in range(4):
                    for wi in (sizes[temp][0]):
                        for wj in (sizes[temp][1]):
                            r = r + src[wi,wj,2]
                            g = g + src[wi,wj,1]
                            b = b + src[wi,wj,0]

    dst[tidx,tidy,2] = r / size*2
    dst[tidx,tidy,1] = g / size*2
    dst[tidx,tidy,0] = b / size*2
    
v_hsv = hostOutput1[:,:,2]
v_hsv = np.ascontiguousarray(v_hsv)

startime_kuwahara = time.time()
kuwahara_gpu[gridSize, blockSize](devInput1, v_hsv,devOutput2,8)
hostOutput2 = devOutput2.copy_to_host()
print("GPU kuwa time :",abs(time.time()-start_hsv))
plt.imsave("phongcanh_kuwahara_GPU.png",hostOutput2)

